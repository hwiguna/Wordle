############################################# WORDLE on the ESP32 by Hari Wiguna, 2023 ############################################## REFERENCES:# https://docs.micropython.org/en/latest/esp8266/tutorial/ssd1306.html# https://github.com/peterhinch/micropython-font-to-py/tree/master/writerimport machineimport ssd1306import timeimport randomimport framebuffrom writer import Writerimport courier20  # Font to use#-- GPIOs --sclPIN,sdaPIN = 33, 34#consPIN, colPIN, vowelPIN, submitPIN, rowPIN = 7,8,9,0,10vowelPIN,consPIN, colPIN,rowPIN, submitPIN,  = 8,7, 9,10, 0#-- OLED --oledWIDTH = 128oledHEIGHT =  32#-- INIT OLED --i2c = machine.SoftI2C( machine.Pin(sclPIN), machine.Pin(sdaPIN) )oled = ssd1306.SSD1306_I2C( oledWIDTH, oledHEIGHT, i2c )wri = Writer(oled, courier20)#-- INIT BUTTONS --colBtn = machine.Pin(colPIN, machine.Pin.IN, machine.Pin.PULL_UP)vowelBtn = machine.Pin(vowelPIN, machine.Pin.IN, machine.Pin.PULL_UP)consBtn = machine.Pin(consPIN, machine.Pin.IN, machine.Pin.PULL_UP)submitBtn = machine.Pin(submitPIN, machine.Pin.IN, machine.Pin.PULL_UP)rowBtn = machine.Pin(rowPIN, machine.Pin.IN, machine.Pin.PULL_UP)#-- GAME --wordle = "TENET"#I think this is a MicroPython bug. in Python it works, but in Micropython, all the rows share the same memory!?#words = [[" "]*5]*6 # six rows of five spaces per row#scores = [[0]*5]*6 # six rows of five zeroes per rowwords = [[' ' for j in range(5)] for i in range(6)] # six rows of five spaces per rowscores = [[0 for j in range(5)] for i in range(6)] # six rows of five zeroes per rowshownRow, curRow, curCol = 0,0,0 #curRow is the row being guessed but not yet submitted. curRow,curCol is where the "cursor" is atboxWidth,boxHeight  = 22, 24vowels = "AEIOUY"consonants = "BCDFGHJKLMNPQRSTVWXZ"isWinner = FalseisLoser = Falsex0 = 6y0 = 8def draw():    oled.fill(0)    # Row Indicator    for i in range(6):        x = 0        y = y0 + i*4        if i==shownRow:            oled.fill_rect(x,y, 3, 3, 1)        else:            oled.fill_rect(x+1,y, 1, 1, 1)    # Column letters    for i in range(5):        x = x0 + i*25        y = y0        # Score for this letter        if shownRow>=curRow:            isWrong, isImperfect, isPerfect = False, False, False        else:            score = scores[shownRow][i]            isWrong = score == 0            isImperfect = score == .5            isPerfect = score == 1                if isPerfect:            oled.fill_rect(x,y, boxWidth, boxHeight, 1) # White Box        else:            oled.rect(x,y, boxWidth, boxHeight, 1) # White Frame            # Show current column as double thick frame            if i==curCol:                oled.rect(x+1,y+1, boxWidth-2, boxHeight-2, 1)                oled.rect(x+2,y+1, boxWidth-4, boxHeight-2, 1)        Writer.set_textpos(oled, y0+3, x+4)        wri.printstring(words[shownRow][i], isPerfect) #Second parameter true means invert the colors        if isWrong: # Cross out wrong letters            oled.line(x,y+1, x+boxWidth-1, y+boxWidth-1, 1)            oled.line(x,y+1+boxWidth-1, x+boxWidth-1, y, 1)    oled.show()def anyButton():    return colBtn.value() == 0 or vowelBtn.value() == 0 or consBtn.value() == 0 or rowBtn.value() == 0def winner():    isOdd = False    while not anyButton():        oled.fill(0)        # Row Indicator        for i in range(6):            x = 0            y = y0 + i*4            if i==shownRow:                oled.fill_rect(x,y, 3, 3, 1)            else:                oled.fill_rect(x+1,y, 1, 1, 1)        isOdd = not isOdd        # Column letters        for i in range(5):            x = x0 + i*25            y = random.randint(0,3) if isOdd else y0            oled.fill_rect(x,y, boxWidth, boxHeight, 1) # White Box            Writer.set_textpos(oled, y+3, x+4)            wri.printstring(words[shownRow][i], True) #Second parameter true means invert the colors        oled.show()        time.sleep(.08)    time.sleep(1)    def loser():    # ByteArray courtesy of:    # https://www.mischianti.org/images-to-byte-array-online-converter-cpp-arduino/    #// 'Frown32', 32x32px    imgBytes = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x3f, 0xfc, 0x00,     0x00, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0x80, 0x03, 0xff, 0xff, 0xc0, 0x07, 0xff, 0xff, 0xe0,     0x0f, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xf0, 0x1f, 0xcf, 0xf3, 0xf8, 0x1f, 0x87, 0xe1, 0xf8,     0x3f, 0x87, 0xe0, 0xfc, 0x3f, 0x87, 0xe1, 0xfc, 0x3f, 0xcf, 0xf1, 0xfc, 0x3f, 0xff, 0xff, 0xfc,     0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xfc,     0x1f, 0xf8, 0x1f, 0xf8, 0x1f, 0xe3, 0xc3, 0xf8, 0x1f, 0x8f, 0xf9, 0xf8, 0x0f, 0xbf, 0xfd, 0xf0,     0x07, 0x3f, 0xfc, 0xe0, 0x03, 0xff, 0xff, 0xe0, 0x01, 0xff, 0xff, 0xc0, 0x00, 0xff, 0xff, 0x00,     0x00, 0x7f, 0xfe, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]    framebuf_obj = framebuf.FrameBuffer( bytearray(imgBytes), 32, 32, framebuf.MONO_HLSB)        showFrown = False    while not anyButton():        oled.fill(0)                Writer.set_textpos(oled, y0+3, x0+4)        wri.printstring(wordle, False) #Second parameter true means invert the colors        showFrown = not showFrown        if showFrown:            oled.blit(framebuf_obj, 128-32, 2) # Copy the frame buffer to the OLED display        oled.show()                    time.sleep(.5)    time.sleep(1)def nextChar(curLetter, chars):    # Compute next character after selected column.  If selected column is not in the chars array, start with the first char.    if curLetter in chars:        curIndex = chars.index(words[curRow][curCol])        nextIndex = curIndex+1 if curIndex < (len(chars)-1) else 0    else:        nextIndex = 0    return chars[nextIndex]def toggleSpaces():    hasBlanks = False    for i in range(5):        if words[curRow][i] == " ":            hasBlanks = True            words[curRow][i] = "?"        else:            if words[curRow][i] == "?":                hasBlanks = True                words[curRow][i] = " "    return hasBlanksdef hasBlanks():    global curRow    hasSpaces = toggleSpaces() # " " to "?"    if hasSpaces:        for count in range(3):            draw()            toggleSpaces() # "?" to " "            time.sleep(.5)    return hasSpaces    def submit():    global curRow, isWinner, isLoser        wordleInUseFlags = [0]*5 # 0=unused, 1=used by a guessed letter        #TEMPORARY clear the score so we could keep resubmitting same row.    for i in range(5):        scores[curRow][i] = 0        # Look for perfect guesses    for i in range(5):        if words[curRow][i] == wordle[i]:            scores[curRow][i] = 1  # Guessed Letter is perfect            wordleInUseFlags[i] = 1# Mark that letter in wordle as used    # For those letters that are not scored yet, see if they're half correct.    for i in range(5):        if scores[curRow][i] == 0: # only pay attention to unaccounted for letters in the guess            for j in range(5):                # Don't compare same index. That's been done by loop above.                # Don't compare against a letter in wordle that's been used before either                if i != j and wordleInUseFlags[j] == 0:                    if words[curRow][i] == wordle[j]:                        scores[curRow][i] = 0.5 # only half correct (correct letter, in wrong place)                                               wordleInUseFlags[j] = 1# Mark that letter in wordle as used    guess = "".join(words[curRow])    isWinner = guess == wordle    if not isWinner:        if curRow<5:            curRow += 1        else:            isLoser = Truedef autoFill():    curWord = ''.join(words[curRow])    if curWord == 'AD   ':        for i,ch in enumerate("ADIEU"):            words[curRow][i] = chdef readButtons():    global shownRow, curCol        canEdit = shownRow==curRow    if canEdit:        colPressed = colBtn.value()==0        vowelPressed = vowelBtn.value() == 0        consPressed = consBtn.value() == 0        submitPressed = submitBtn.value() == 0                if colPressed:            curCol = curCol+1 if curCol<4 else 0            draw()            time.sleep(.1)                if vowelPressed:            words[curRow][curCol] = nextChar(words[curRow][curCol], vowels)            autoFill()            draw()            time.sleep(.1)                if consPressed:            words[curRow][curCol] = nextChar(words[curRow][curCol], consonants)            autoFill()            draw()            time.sleep(.1)                if submitPressed:            if not hasBlanks():                submit()                if isWinner:                    winner()                if isLoser:                    loser()            draw()            time.sleep(.1)            if rowBtn.value()==0:        shownRow = shownRow+1 if shownRow<curRow else 0        draw()        time.sleep(.1)def pickaWordle():    global wordle    with open('words.txt', 'r') as file:        wordles = file.readlines()    randomIndex = random.randint(0,len(wordles)-1)    wordle = wordles[ randomIndex ][:5].upper()    print(wordle)        #Shows Wordle upon start. Uncomment for debugging and testing#     for i in range(5):#         words[0][i]=wordle[i]#== MAIN ==pickaWordle()while True:    draw()    readButtons()