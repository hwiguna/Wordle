############################################# WORDLE on the ESP32 by Hari Wiguna, 2023 ############################################## REFERENCES:# https://docs.micropython.org/en/latest/esp8266/tutorial/ssd1306.html# https://github.com/peterhinch/micropython-font-to-py/tree/master/writerimport machineimport ssd1306import timeimport randomfrom writer import Writerimport courier20  # Font to use#-- GPIOs --sclPIN,sdaPIN = 33, 34#consPIN, colPIN, vowelPIN, submitPIN, rowPIN = 7,8,9,0,10vowelPIN,consPIN, colPIN,rowPIN, submitPIN,  = 8,7, 9,10, 0#-- OLED --oledWIDTH = 128oledHEIGHT =  32#-- INIT OLED --i2c = machine.SoftI2C( machine.Pin(sclPIN), machine.Pin(sdaPIN) )oled = ssd1306.SSD1306_I2C( oledWIDTH, oledHEIGHT, i2c )wri = Writer(oled, courier20)#-- INIT BUTTONS --colBtn = machine.Pin(colPIN, machine.Pin.IN, machine.Pin.PULL_UP)vowelBtn = machine.Pin(vowelPIN, machine.Pin.IN, machine.Pin.PULL_UP)consBtn = machine.Pin(consPIN, machine.Pin.IN, machine.Pin.PULL_UP)submitBtn = machine.Pin(submitPIN, machine.Pin.IN, machine.Pin.PULL_UP)rowBtn = machine.Pin(rowPIN, machine.Pin.IN, machine.Pin.PULL_UP)#-- GAME --wordle = "TENET"#I think this is a MicroPython bug. in Python it works, but in Micropython, all the rows share the same memory!?#words = [[" "]*5]*6 # six rows of five spaces per row#scores = [[0]*5]*6 # six rows of five zeroes per rowwords = [[' ' for j in range(5)] for i in range(6)] # six rows of five spaces per rowscores = [[0 for j in range(5)] for i in range(6)] # six rows of five zeroes per rowshownRow, curRow, curCol = 0,0,0 #curRow is the row being guessed but not yet submitted. curRow,curCol is where the "cursor" is atboxWidth,boxHeight  = 22, 24vowels = "AEIOUY"consonants = "BCDFGHJKLMNPQRSTVWXZ"gameOver = Falsedef draw():    x0 = 6    oled.fill(0)    # Row Indicator    for i in range(6):        x = 0        y = i*4        if i==shownRow:            oled.fill_rect(x,y, 3, 3, 1)        else:            oled.fill_rect(x+1,y, 1, 1, 1)    # Column letters    for i in range(5):        x = x0 + i*25        y = 0        # Score for this letter        if shownRow>=curRow:            isWrong, isImperfect, isPerfect = False, False, False        else:            score = scores[shownRow][i]            isWrong = score == 0            isImperfect = score == .5            isPerfect = score == 1                if isPerfect:            oled.fill_rect(x,y, boxWidth, boxHeight, 1) # White Box        else:            oled.rect(x,y, boxWidth, boxHeight, 1) # White Frame            # Show current column as double thick frame            if i==curCol:                oled.rect(x+1,y+1, boxWidth-2, boxHeight-2, 1)                oled.rect(x+2,y+1, boxWidth-4, boxHeight-2, 1)        Writer.set_textpos(oled, 3, x+4)        wri.printstring(words[shownRow][i], isPerfect) #Second parameter true means invert the colors        if isWrong: # Cross out wrong letters            oled.line(x,y+1, x+boxWidth-1, y+boxWidth-1, 1)            oled.line(x,y+1+boxWidth-1, x+boxWidth-1, y, 1)    oled.show()def nextChar(curLetter, chars):    # Compute next character after selected column.  If selected column is not in the chars array, start with the first char.    if curLetter in chars:        curIndex = chars.index(words[curRow][curCol])        nextIndex = curIndex+1 if curIndex < (len(chars)-1) else 0    else:        nextIndex = 0    return chars[nextIndex]def submit():    global curRow, gameOver        wordleInUseFlags = [0]*5 # 0=unused, 1=used by a guessed letter        #TEMPORARY clear the score so we could keep resubmitting same row.    for i in range(5):        scores[curRow][i] = 0        # Look for perfect guesses    for i in range(5):        if words[curRow][i] == wordle[i]:            scores[curRow][i] = 1  # Guessed Letter is perfect            wordleInUseFlags[i] = 1# Mark that letter in wordle as used    # For those letters that are not scored yet, see if they're half correct.    for i in range(5):        if scores[curRow][i] == 0: # only pay attention to unaccounted for letters in the guess            for j in range(5):                # Don't compare same index. That's been done by loop above.                # Don't compare against a letter in wordle that's been used before either                if i != j and wordleInUseFlags[j] == 0:                    if words[curRow][i] == wordle[j]:                        scores[curRow][i] = 0.5 # only half correct (correct letter, in wrong place)                                               wordleInUseFlags[j] = 1# Mark that letter in wordle as used    print("scores",scores[curRow])    print("wordleInUseFlags",wordleInUseFlags)    if curRow<5:        curRow += 1    else:        gameOver = Truedef autoFill():    curWord = ''.join(words[curRow])    if curWord == 'AD   ':        for i,ch in enumerate("ADIEU"):            words[curRow][i] = chdef readButtons():    global shownRow, curCol        canEdit = shownRow==curRow    if canEdit:        if colBtn.value()==0:            curCol = curCol+1 if curCol<4 else 0            draw()            time.sleep(.1)                if vowelBtn.value() == 0:            print("before",words)            words[curRow][curCol] = nextChar(words[curRow][curCol], vowels)            autoFill()            draw()            time.sleep(.1)                if consBtn.value() == 0:            words[curRow][curCol] = nextChar(words[curRow][curCol], consonants)            autoFill()            draw()            time.sleep(.1)                if submitBtn.value() == 0:            submit()            draw()            time.sleep(.1)            if rowBtn.value()==0:        shownRow = shownRow+1 if shownRow<curRow else 0        draw()        time.sleep(.1)def pickaWordle():    global wordle    with open('words.txt', 'r') as file:        wordles = file.readlines()    randomIndex = random.randint(0,len(wordles)-1)    wordle = wordles[ randomIndex ][:5].upper()#== MAIN ==pickaWordle()while True:    draw()    readButtons()